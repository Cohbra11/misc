// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// ©jdehorty

//@version=5
strategy("Demo GPT - Machine Learning: Lorentzian Classification", "Lorentzian Classification", overlay=true, precision=4, commission_type=strategy.commission.percent, commission_value=0.1, initial_capital=1000, slippage=3)

// Date Range Inputs
startDate = input.time(timestamp("2018-01-01"), title="Start Date")
endDate = input.time(timestamp("2069-12-31"), title="End Date")

import jdehorty/MLExtensions/2 as ml
import jdehorty/KernelFunctions/2 as kernels

// General Settings
var source = input.source(title='Source', defval=close, group="General Settings", tooltip="Source of the input data")
var neighborsCount = input.int(title='Neighbors Count', defval=8, group="General Settings", minval=1, maxval=100, step=1, tooltip="Number of neighbors to consider")
var maxBarsBack = input.int(title="Max Bars Back", defval=2000, group="General Settings")
var featureCount = input.int(title="Feature Count", defval=5, group="Feature Engineering", minval=2, maxval=5, tooltip="Number of features to use for ML predictions.")
var colorCompression = input.int(title="Color Compression", defval=1, group="General Settings", minval=1, maxval=10, tooltip="Compression factor for adjusting the intensity of the color scale.")
var showExits = input.bool(title="Show Default Exits", defval=false, group="General Settings", tooltip="Default exits occur exactly 4 bars after an entry signal.")
var useDynamicExits = input.bool(title="Use Dynamic Exits", defval=false, group="General Settings", tooltip="Dynamic exits attempt to let profits ride by dynamically adjusting the exit threshold based on kernel regression.")

// Trade Stats Settings
showTradeStats = input.bool(true, 'Show Trade Stats', tooltip='Displays the trade stats for a given configuration.')
useWorstCase = input.bool(false, "Use Worst Case Estimates", tooltip="Whether to use the worst case scenario for backtesting.")

// Filter Settings
var useVolatilityFilter = input.bool(title="Use Volatility Filter", defval=true, tooltip="Whether to use the volatility filter.", group="Filters")
var useRegimeFilter = input.bool(title="Use Regime Filter", defval=true, group="Filters", inline="regime")
var useAdxFilter = input.bool(title="Use ADX Filter", defval=false, group="Filters", inline="adx")
var regimeThreshold = input.float(title="Threshold", defval=-0.1, minval=-10, maxval=10, step=0.1, tooltip="Whether to use the trend detection filter. Threshold for detecting Trending/Ranging markets.", group="Filters", inline="regime")
var adxThreshold = input.int(title="Threshold", defval=20, minval=0, maxval=100, step=1, tooltip="Whether to use the ADX filter. Threshold for detecting Trending/Ranging markets.", group="Filters", inline="adx")

// Feature Variables
f1_string = input.string(title="Feature 1", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline="01", group="Feature Engineering")
f1_paramA = input.int(title="Parameter A", defval=14, inline="02", group="Feature Engineering")
f1_paramB = input.int(title="Parameter B", defval=1, inline="02", group="Feature Engineering")
f2_string = input.string(title="Feature 2", options=["RSI", "WT", "CCI", "ADX"], defval="WT", inline="03", group="Feature Engineering")
f2_paramA = input.int(title="Parameter A", defval=10, inline="04", group="Feature Engineering")
f2_paramB = input.int(title="Parameter B", defval=11, inline="04", group="Feature Engineering")
f3_string = input.string(title="Feature 3", options=["RSI", "WT", "CCI", "ADX"], defval="CCI", inline="05", group="Feature Engineering")
f3_paramA = input.int(title="Parameter A", defval=20, inline="06", group="Feature Engineering")
f3_paramB = input.int(title="Parameter B", defval=1, inline="06", group="Feature Engineering")
f4_string = input.string(title="Feature 4", options=["RSI", "WT", "CCI", "ADX"], defval="ADX", inline="07", group="Feature Engineering")
f4_paramA = input.int(title="Parameter A", defval=20, inline="08", group="Feature Engineering")
f4_paramB = input.int(title="Parameter B", defval=2, inline="08", group="Feature Engineering")
f5_string = input.string(title="Feature 5", options=["RSI", "WT", "CCI", "ADX"], defval="RSI", inline="09", group="Feature Engineering")
f5_paramA = input.int(title="Parameter A", defval=9, inline="10", group="Feature Engineering")
f5_paramB = input.int(title="Parameter B", defval=1, inline="10", group="Feature Engineering")

// Feature Series Functions
series_from(feature_string, _close, _high, _low, _hlc3, f_paramA, f_paramB) =>
    switch feature_string
        "RSI" => ml.n_rsi(_close, f_paramA, f_paramB)
        "WT" => ml.n_wt(_hlc3, f_paramA, f_paramB)
        "CCI" => ml.n_cci(_close, f_paramA, f_paramB)
        "ADX" => ml.n_adx(_high, _low, _close, f_paramA)

// Feature Arrays Setup
var f1Array = array.new_float()
var f2Array = array.new_float()
var f3Array = array.new_float()
var f4Array = array.new_float()
var f5Array = array.new_float()

// Feature Series Calculations
var featureSeriesF1 = series_from(f1_string, close, high, low, hlc3, f1_paramA, f1_paramB)
var featureSeriesF2 = series_from(f2_string, close, high, low, hlc3, f2_paramA, f2_paramB)
var featureSeriesF3 = series_from(f3_string, close, high, low, hlc3, f3_paramA, f3_paramB)
var featureSeriesF4 = series_from(f4_string, close, high, low, hlc3, f4_paramA, f4_paramB)
var featureSeriesF5 = series_from(f5_string, close, high, low, hlc3, f5_paramA, f5_paramB)

array.push(f1Array, featureSeriesF1)
array.push(f2Array, featureSeriesF2)
array.push(f3Array, featureSeriesF3)
array.push(f4Array, featureSeriesF4)
array.push(f5Array, featureSeriesF5)

// Lorentzian Distance Function
get_lorentzian_distance(int i, int featureCount) =>
    switch featureCount
        5 => math.log(1+math.abs(featureSeriesF1 - array.get(f1Array, i))) + 
             math.log(1+math.abs(featureSeriesF2 - array.get(f2Array, i))) + 
             math.log(1+math.abs(featureSeriesF3 - array.get(f3Array, i))) + 
             math.log(1+math.abs(featureSeriesF4 - array.get(f4Array, i))) + 
             math.log(1+math.abs(featureSeriesF5 - array.get(f5Array, i)))
        4 => math.log(1+math.abs(featureSeriesF1 - array.get(f1Array, i))) +
             math.log(1+math.abs(featureSeriesF2 - array.get(f2Array, i))) +
             math.log(1+math.abs(featureSeriesF3 - array.get(f3Array, i))) +
             math.log(1+math.abs(featureSeriesF4 - array.get(f4Array, i)))
        3 => math.log(1+math.abs(featureSeriesF1 - array.get(f1Array, i))) +
             math.log(1+math.abs(featureSeriesF2 - array.get(f2Array, i))) +
             math.log(1+math.abs(featureSeriesF3 - array.get(f3Array, i)))
        2 => math.log(1+math.abs(featureSeriesF1 - array.get(f1Array, i))) +
             math.log(1+math.abs(featureSeriesF2 - array.get(f2Array, i)))

// Direction Constants
var DIRECTION_LONG = 1
var DIRECTION_SHORT = -1
var DIRECTION_NEUTRAL = 0

// Training Data Setup
y_train_series = source[4] < source[0] ? DIRECTION_SHORT : source[4] > source[0] ? DIRECTION_LONG : DIRECTION_NEUTRAL
var y_train_array = array.new_int(0)
array.push(y_train_array, y_train_series)

// ML Model Variables
var predictions = array.new_float(0)
var prediction = 0.0
var signal = DIRECTION_NEUTRAL
var distances = array.new_float(0)

// Derived Settings
maxBarsBackIndex = last_bar_index >= maxBarsBack ? last_bar_index - maxBarsBack : 0

// Core ML Logic Implementation
lastDistance = -1.0
size = math.min(maxBarsBack-1, array.size(y_train_array)-1)
sizeLoop = math.min(maxBarsBack-1, size)

if bar_index >= maxBarsBackIndex
    for i = 0 to sizeLoop
        d = get_lorentzian_distance(i, featureCount)
        if d >= lastDistance and i%4
            lastDistance := d
            array.push(distances, d)
            array.push(predictions, math.round(array.get(y_train_array, i)))
            if array.size(predictions) > neighborsCount
                lastDistance := array.get(distances, math.round(neighborsCount*3/4))
                array.shift(distances)
                array.shift(predictions)
    prediction := array.sum(predictions)

// Filters
filter_volatility = ml.filter_volatility(1, 10, useVolatilityFilter)
filter_regime = ml.regime_filter(ohlc4, regimeThreshold, useRegimeFilter)
filter_adx = ml.filter_adx(source, 14, adxThreshold, useAdxFilter)
filter_all = filter_volatility and filter_regime and filter_adx

// Signal Generation
signal := prediction > 0 and filter_all ? DIRECTION_LONG : prediction < 0 and filter_all ? DIRECTION_SHORT : nz(signal[1])
// Bar-Count and Position Management
var int barsHeld = 0
barsHeld := ta.change(signal) ? 0 : barsHeld + 1
isHeldFourBars = barsHeld == 4
isHeldLessThanFourBars = 0 < barsHeld and barsHeld < 4

// Fractal Filters
isDifferentSignalType = ta.change(signal)
isEarlySignalFlip = ta.change(signal) and (ta.change(signal[1]) or ta.change(signal[2]) or ta.change(signal[3]))

// EMA Filter Settings
useEmaFilter = input.bool(title="Use EMA Filter", defval=false, group="Filters", inline="ema")
emaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="ema")
isEmaUptrend = useEmaFilter ? close > ta.ema(close, emaPeriod) : true

// SMA Filter Settings
useSmaFilter = input.bool(title="Use SMA Filter", defval=false, group="Filters", inline="sma")
smaPeriod = input.int(title="Period", defval=200, minval=1, step=1, group="Filters", inline="sma")
isSmaUptrend = useSmaFilter ? close > ta.sma(close, smaPeriod) : true

// Kernel Settings
useKernelFilter = input.bool(true, "Trade with Kernel", group="Kernel Settings", inline="kernel")
showKernelEstimate = input.bool(true, "Show Kernel Estimate", group="Kernel Settings", inline="kernel")
useKernelSmoothing = input.bool(false, "Enhance Kernel Smoothing", group="Kernel Settings")
h = input.int(8, 'Lookback Window', minval=3, group="Kernel Settings")
r = input.float(8., 'Relative Weighting', step=0.25, group="Kernel Settings")
x = input.int(25, "Regression Level", group="Kernel Settings")
lag = input.int(2, "Lag", group="Kernel Settings")

// Kernel Regression Calculations
yhat1 = kernels.rationalQuadratic(source, h, r, x)
yhat2 = kernels.gaussian(source, h-lag, x)
kernelEstimate = yhat1

// Kernel State Detection
bool wasBearishRate = yhat1[2] > yhat1[1]
bool wasBullishRate = yhat1[2] < yhat1[1]
bool isBearishRate = yhat1[1] > yhat1
bool isBullishRate = yhat1[1] < yhat1
isBearishChange = isBearishRate and wasBullishRate
isBullishChange = isBullishRate and wasBearishRate

// Kernel Crossover Detection
bool isBullishCrossAlert = ta.crossover(yhat2, yhat1)
bool isBearishCrossAlert = ta.crossunder(yhat2, yhat1)
bool isBullishSmooth = yhat2 >= yhat1
bool isBearishSmooth = yhat2 <= yhat1

// Kernel Visualization
c_green = color.new(#009988, 20)
c_red = color.new(#CC3311, 20)
transparent = color.new(#000000, 100)
colorByCross = isBullishSmooth ? c_green : c_red
colorByRate = isBullishRate ? c_green : c_red
plotColor = showKernelEstimate ? (useKernelSmoothing ? colorByCross : colorByRate) : transparent
plot(kernelEstimate, color=plotColor, linewidth=2, title="Kernel Regression Estimate")

// Entry/Exit Signal Generation
isBullish = useKernelFilter ? (useKernelSmoothing ? isBullishSmooth : isBullishRate) : true
isBearish = useKernelFilter ? (useKernelSmoothing ? isBearishSmooth : isBearishRate) : true

// Trading Conditions
isBuySignal = signal == DIRECTION_LONG and isEmaUptrend and isSmaUptrend
isLastSignalBuy = signal[4] == DIRECTION_LONG and isEmaUptrend[4] and isSmaUptrend[4]
isNewBuySignal = isBuySignal and isDifferentSignalType

// Exit Conditions
endLongTradeStrict = ((isHeldFourBars and isLastSignalBuy) or (isHeldLessThanFourBars and isNewBuySignal and isLastSignalBuy)) and strategy.position_size > 0
isDynamicExitValid = not useEmaFilter and not useSmaFilter and not useKernelSmoothing
endLongTradeDynamic = (isBearishChange and isDynamicExitValid) and strategy.position_size > 0
endLongTrade = useDynamicExits ? endLongTradeDynamic : endLongTradeStrict

// Strategy Execution
if isNewBuySignal and isBullish and time >= startDate and time <= endDate
    strategy.entry("Long", strategy.long, comment="ML Long Entry")

if endLongTrade and time >= startDate and time <= endDate
    strategy.close("Long", comment="ML Long Exit")

// Display Settings
showBarColors = input.bool(true, "Show Bar Colors", group="Display Settings")
showBarPredictions = input.bool(defval=true, title="Show Bar Prediction Values", group="Display Settings")
useAtrOffset = input.bool(defval=false, title="Use ATR Offset", group="Display Settings")
barPredictionsOffset = input.float(0, "Bar Prediction Offset", minval=0, group="Display Settings")

// Visualization
atrSpaced = useAtrOffset ? ta.atr(1) : na
compressionFactor = neighborsCount / colorCompression
c_pred = prediction > 0 ? color.from_gradient(prediction, 0, compressionFactor, #787b86, #009988) : 
   prediction <= 0 ? color.from_gradient(prediction, -compressionFactor, 0, #CC3311, #787b86) : na
c_label = showBarPredictions ? c_pred : na
c_bars = showBarColors ? color.new(c_pred, 50) : na
x_val = bar_index
y_val = useAtrOffset ? prediction > 0 ? high + atrSpaced : low - atrSpaced : 
   prediction > 0 ? high + hl2*barPredictionsOffset/20 : low - hl2*barPredictionsOffset/30

label.new(x_val, y_val, str.tostring(prediction), xloc.bar_index, yloc.price, 
   color.new(color.white, 100), label.style_label_up, c_label, size.normal, text.align_left)
barcolor(showBarColors ? color.new(c_pred, 50) : na)

plotshape(isNewBuySignal ? low : na, 'Buy', shape.labelup, location.belowbar, 
   color=ml.color_green(prediction), size=size.small)
plotshape(endLongTrade and showExits ? high : na, 'StopBuy', shape.xcross, 
   location.absolute, color=#3AFF17, size=size.tiny)

// Alerts
//alertcondition(isNewBuySignal, title='Open Long ▲', 
//   message='LDC Open Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(endLongTrade, title='Close Long ▲', 
//   message='LDC Close Long ▲ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(isBullishChange, title='Kernel Bullish Color Change', 
//   message='LDC Kernel Bullish ▲ | {{ticker}}@{{close}} | ({{interval}})')
//alertcondition(isBearishChange, title='Kernel Bearish Color Change', 
//   message='LDC Kernel Bearish ▼ | {{ticker}}@{{close}} | ({{interval}})')